from dotenv import load_dotenv
import os
from fastapi import FastAPI,Body,BackgroundTasks
from fastapi.middleware.cors import CORSMiddleware
import requests
import base64
from typing import Dict
import asyncio
import httpx 
import json
import time
import re

load_dotenv()
OPENAI_BASE_URL = "https://aipipe.org/openrouter/v1"
MODEL_NAME = "google/gemini-2.0-flash-lite-001" 






app = FastAPI(
    title="LLM Code Deployment", 
    version="1.0.0",
    description="An API for automated code generation and deployment using LLMs"
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
    expose_headers=["*"],
)


GITHUB_TOKEN = os.getenv("GITHUB_TOKEN")
AIPIPE_TOKEN = os.getenv("AIPIPE_TOKEN") 
STUDENT_SECRET = os.getenv("STUDENT_SECRET", "default-secret")
STUDENT_EMAIL = os.getenv("STUDENT_EMAIL", "23f3004092@ds.study.iitm.ac.in")

import re

def try_fix_json(text):
    text = text.strip()
    text = re.sub(r"(?<!\\)\\(?![\"\\/bfnrtu])", r"\\\\", text)
    return text





def validate_secret(secret: str) -> bool:
    return secret == STUDENT_SECRET



def decode_attachment(attachment: Dict[str, str]) -> bytes:
    """Decode base64 or remote attachment data."""
    url = attachment.get("url", "")
    if url.startswith("data:"):
        try:
            _, data = url.split(",", 1)
            return base64.b64decode(data)
        except Exception:
            return b""
    elif url.startswith("http"):
        try:
            res = requests.get(url)
            return res.content
        except Exception:
            return b""
    return b""



def deploy_github_pages():
    pass

def generate_code(data: dict):
    brief = data.get("brief", "No brief provided.")
    checks = data.get("checks", [])
    attachments = data.get("attachments", [])
    attachment_info = []

    for i, attachment in enumerate(attachments):
        try:
            file_data = decode_attachment(attachment)
            if not file_data:
                raise ValueError("Empty file data")

            try:
                decoded_text = file_data.decode("utf-8")
                attachment_info.append(
                    f"Attachment {i+1}: {attachment.get('name', 'unnamed')} "
                    f"({len(file_data)} bytes)\nPreview:\n{decoded_text}"
                )
            except UnicodeDecodeError:
                attachment_info.append(
                    f"Attachment {i+1}: {attachment.get('name', 'unnamed')} "
                    f"({len(file_data)} bytes, binary file)"
                )

        except Exception:
            attachment_info.append(
                f"Attachment {i+1}: {attachment.get('name', 'unknown')} (failed to decode)"
            )

    user_prompt = f"""Create a complete, production-ready web application based on this brief:
{brief}

Attachments available:
{chr(10).join(attachment_info) if attachment_info else 'No attachments provided'}

Important:
- Embed all image attachments directly in index.html using <img src="data:image/png;base64,..."> if required and donot add anything extra for the base64 code(like using frnces ///,```,etc)
- Display text file attachments in the app.
- Provide download links for other files.
The generated files and index.html app must ensure to complete these checks:
{checks}
These checks must be passed by the code you generate.
"""

    payload = {
        "model": "google/gemini-2.0-flash-lite-001",
        "messages": [
            {
                "role": "system",
                "content": (
                    "You are an expert web developer who creates clean, modern, "
                    "production-ready web applications. Always return complete, functional HTML code only Use only a index.html to genearte every part of task.Use CSS,JS and everything along with attachments in it. "
                    "and a Readme.md and MIT license files Use index.html as name of main file. Use README.md as name of readme file. Use LICENSE as name of license file.The code generated by you will be deployed on github using github pages. "
                )
            },
            {"role": "user", "content": user_prompt}
        ],
        "response_format":{"type": "json_schema", "json_schema": {
  "name": "file_list",
  "schema": {
    "type": "object",
    "properties": {
      "files": {
        "type": "array",
        "items": {
          "type": "object",
          "properties": {
            "name": {"type": "string"},
            "content": {"type": "string"}
          },
          "required": ["name", "content"]
        }
      }
    },
    "required": ["files"]
  }
}}

    }

    url = f"{OPENAI_BASE_URL}/chat/completions"
    headers = {
        "Authorization": f"Bearer {AIPIPE_TOKEN}",
        "Content-Type": "application/json"
    }

    with httpx.Client(timeout=300.0) as client:
        response = client.post(url, headers=headers, json=payload)
        if response.status_code != 200:
            print("OpenAI API error:", response.status_code, response.text)
            return []
        result = response.json()
        # Extract the content from the response
        ai_content = result["choices"][0]["message"]["content"]
        # Try to fix and parse the JSON output from the LLM
        try:
            
           files_dict = json.loads(ai_content)
           files = files_dict["files"]
        except json.JSONDecodeError as e:
            print("Failed to parse JSON:", e)
            files = []
    print("Generated files:", files)
    return(files)



def generate_code2(data: dict,old_files: list):
    brief = data.get("brief", "No brief provided.")
    checks = data.get("checks", [])
    attachments = data.get("attachments", [])
    attachment_info = []

    for i, attachment in enumerate(attachments):
        try:
            file_data = decode_attachment(attachment)
            if not file_data:
                raise ValueError("Empty file data")

            try:
                decoded_text = file_data.decode("utf-8")
                attachment_info.append(
                    f"Attachment {i+1}: {attachment.get('name', 'unnamed')} "
                    f"({len(file_data)} bytes)\nPreview:\n{decoded_text}"
                )
            except UnicodeDecodeError:
                attachment_info.append(
                    f"Attachment {i+1}: {attachment.get('name', 'unnamed')} "
                    f"({len(file_data)} bytes, binary file)"
                )

        except Exception:
            attachment_info.append(
                f"Attachment {i+1}: {attachment.get('name', 'unknown')} (failed to decode)"
            )

    user_prompt = f"""You have to make changes(like adding,removing features,making new components,making changes,etc...) in an existing codebase of a github repo ,Create a complete, production-ready web application based on these changes:
{brief}
The current codebase is as follows:
{old_files}



Attachments available:
{chr(10).join(attachment_info) if attachment_info else 'No attachments provided'}

Important:
- Embed all image attachments directly in index.html using <img src="data:image/png;base64,..."> if required and donot add anything extra for the base64 code(like using fences ///,```,etc)
- Display text file attachments in the app.
- Provide download links for other files.
The generated files and index.html app must ensure to complete these checks:
{checks}
These checks must be passed by the code you generate.
"""

    payload = {
        "model": "google/gemini-2.0-flash-lite-001",
        "messages": [
            {
                "role": "system",
                "content": (
                    "You are an expert web developer who creates clean, modern, "
                    "production-ready web applications. Always return complete, functional HTML code only Use only a index.html to genearte every part of task.Use CSS,JS and everything along with attachments in it. "
                    "and a Readme.md and MIT license files Use index.html as name of main file. Use README.md as name of readme file. Use LICENSE as name of license file.The code generated by you will be deployed on github using github pages."
                )
            },
            {"role": "user", "content": user_prompt}
        ],
        "response_format":{"type": "json_schema", "json_schema": {
  "name": "file_list",
  "schema": {
    "type": "object",
    "properties": {
      "files": {
        "type": "array",
        "items": {
          "type": "object",
          "properties": {
            "name": {"type": "string"},
            "content": {"type": "string"}
          },
          "required": ["name", "content"]
        }
      }
    },
    "required": ["files"]
  }
}}

    }

    url = f"{OPENAI_BASE_URL}/chat/completions"
    headers = {
        "Authorization": f"Bearer {AIPIPE_TOKEN}",
        "Content-Type": "application/json"
    }

    with httpx.Client(timeout=300.0) as client:
        response = client.post(url, headers=headers, json=payload)
        if response.status_code != 200:
            print("OpenAI API error:", response.status_code, response.text)
            return []
        result = response.json()
        # Extract the content from the response
        ai_content = result["choices"][0]["message"]["content"]
        # Try to fix and parse the JSON output from the LLM
        try:
            
           files_dict = json.loads(ai_content)
           files = files_dict["files"]
        except json.JSONDecodeError as e:
            print("Failed to parse JSON:", e)
            files = []
    print("Generated files:", files)
    return(files)

def fetch_repo_files(repo_name: str):
    headers = {
        "Authorization": f"Bearer {GITHUB_TOKEN}",
        "Accept": "application/vnd.github+json"
    }
    url = f"https://api.github.com/repos/23f3004092/{repo_name}/contents"
    response = requests.get(url, headers=headers)
    if response.status_code != 200:
        print("Failed to fetch repo files:", response.text)
        return []
    files = []
    for file in response.json():
        if file["type"] == "file":
            content = base64.b64decode(file["content"]).decode("utf-8", errors="ignore") if "content" in file else requests.get(file["download_url"]).text
            files.append({"name": file["name"], "content": content})
    return files
     
        
    

def create_repo(repo_name: str):
    #create a github repo with the name repo_name using github api
    payload={"name":repo_name,"private":False,"auto_init": True}
    headers={"Authorization": f"Bearer {GITHUB_TOKEN}",
             "Accept": "application/vnd.github+json"}
    response=requests.post("https://api.github.com/user/repos",headers=headers,json=payload)
    if response.status_code not in [200, 201]:
        print("Repo creation failed:", response.text)
        return {}
    return response.json()
    
    
    

"""def enable_github_pages(repo_name: str):
    #enable github pages for the repo created in create_repo function
    payload={"build_type":"legacy","source":{"branch":"main","path":"/"}}
    headers={"Authorization": f"Bearer {GITHUB_TOKEN}",
             "Accept": "application/vnd.github+json"}
    
    response = requests.post(
    f"https://api.github.com/repos/23f3004092/{repo_name}/pages",
    headers=headers,
    json=payload
)
    print(response.status_code, response.json())
    
    
    pass"""
    
def enable_github_pages(repo_name: str):
    """Enable GitHub Pages and wait until it is fully deployed."""
    headers = {
        "Authorization": f"Bearer {GITHUB_TOKEN}",
        "Accept": "application/vnd.github+json"
    }
    payload = {"build_type": "legacy", "source": {"branch": "main", "path": "/"}}

    # Step 1: Enable pages
    response = requests.post(
        f"https://api.github.com/repos/23f3004092/{repo_name}/pages",
        headers=headers,
        json=payload
    )

    if response.status_code not in [200, 201, 202]:
        print("Failed to enable GitHub Pages:", response.text)
        return None

    print("GitHub Pages setup started...")

    # Step 2: Poll the status until it's built
    pages_url = f"https://api.github.com/repos/23f3004092/{repo_name}/pages"
    live_url = None

    for attempt in range(50):  # try for ~90 seconds
        time.sleep(10)
        status_res = requests.get(pages_url, headers=headers)
        if status_res.status_code == 200:
            status_data = status_res.json()
            status = status_data.get("status", "")
            live_url = status_data.get("html_url")
            print(f"[{attempt+1}] GitHub Pages status: {status}")

            if status == "built" and live_url:
                # Verify the page is actually accessible
                try:
                    live_check = requests.get(live_url, timeout=5)
                    if live_check.status_code == 200:
                        print("✅ GitHub Pages is live at:", live_url)
                        return live_url
                except Exception:
                    pass
        else:
            print(f"Waiting for pages setup... (status {status_res.status_code})")

    print("❌ Timeout: GitHub Pages did not become live in time.")
    return live_url



def push_files_to_repo(repo_name: str, files: list[dict]):
    headers = {
        "Authorization": f"Bearer {GITHUB_TOKEN}",
        "Accept": "application/vnd.github+json"
    }
   
    for file in files:
        url = f"https://api.github.com/repos/23f3004092/{repo_name}/contents/{file['name']}"

        res = requests.get(url, headers=headers)
        sha = res.json()["sha"] if res.status_code == 200 else None

        payload = {
            "message": f"Add or update {file['name']}",
            "content": base64.b64encode(file["content"].encode()).decode()
        }
        if sha:
            payload["sha"] = sha

        response = requests.put(url, headers=headers, json=payload)
        if response.status_code in [200, 201]:
            last_commit = response.json().get("commit", {}).get("sha")
        else:
            print(f"Failed to push {file['name']}: {response.text}")
        #print(response.status_code, response.json())
    return last_commit
    





def run_task(data: dict):
    """Run the task in the background and report results."""
    task_round = data.get("round")
    repo_name = f"{data['task']}"
    nonceee=data.get('nonce')
    email=data.get('email',STUDENT_EMAIL)
    task=data.get('task')
    
    if task_round == 1:
        print("=== Starting Round 1 ===")
        files = generate_code(data)
        repo_info = create_repo(repo_name)
        commit_sha = push_files_to_repo(repo_name, files)
        live_url = enable_github_pages(repo_name)

        repo_url = repo_info.get("html_url", f"https://github.com/23f3004092/{repo_name}")

        # Waited for deployment — now report results
        payload = {
            "email": email,
            "task": task,
            "round": task_round,
            "nonce": nonceee,
            "repo_url": repo_url,
            "commit_sha": commit_sha,
            "pages_url": live_url,
        
        }
        evaluation_url = data.get("evaluation_url")
        if evaluation_url:
            requests.post(evaluation_url, json=payload)
        
        return {"message": "Round 1 complete"}
        

    elif task_round == 2:
        print("=== Starting Round 2 ===")
        
        # implement your round2 logic
        round1_files=fetch_repo_files(repo_name)
        new_files = generate_code2(data,round1_files)
        commit_sha = push_files_to_repo(repo_name, new_files)
        #time.sleep(240)
        #live_url = enable_github_pages(repo_name)
        repo_url = f"https://github.com/23f3004092/{repo_name}"
        
        headers = {
            "Authorization": f"Bearer {GITHUB_TOKEN}",
            "Accept": "application/vnd.github+json"
        }
        pages_url = f"https://api.github.com/repos/23f3004092/{repo_name}/pages"
        live_url = None
        time.sleep(3)  # Initial wait before polling
        

        for attempt in range(50): 
            time.sleep(10)  
            status_res = requests.get(pages_url, headers=headers)
            if status_res.status_code == 200:
                status_data = status_res.json()
                status = status_data.get("status", "")
                live_url = status_data.get("html_url")
                print(f"[{attempt+1}] GitHub Pages status: {status}")
                if status == "built" and live_url:
                    # Verify the page is accessible
                    try:
                        live_check = requests.get(live_url, timeout=5)
                        if live_check.status_code == 200:
                            print("✅ GitHub Pages updated and live at:", live_url)
                            break
                    except Exception:
                        pass
            else:
                print(f"Waiting for Pages rebuild... (status {status_res.status_code})")

        if not live_url:
            print("❌ Timeout: GitHub Pages did not rebuild in time.")
            
        payload={
            "email": email,
            "task": task,
            "round": task_round,
            "nonce": nonceee,
            "repo_url": repo_url,
            "commit_sha": commit_sha,
            "pages_url": live_url,
            
        }

        repo_url = f"https://github.com/23f3004092/{repo_name}"
        print("Round 2 complete. Repo URL:", repo_url, "Live URL:", live_url)
        evaluation_url = data.get("evaluation_url")
        if evaluation_url:
            requests.post(evaluation_url, json=payload)
            
        return {"message": "Round 2 complete"}





"""@app.post("/handle_task")
def handle_token(data: dict = Body(...)):
    if not validate_secret(data.get("secret", "")):
        return {"error": "Invalid secret"}
    else:
        if data.get("round") == 1:
            round1(data)
        elif data.get("round") == 2:
            round2(data)
        else:
            return {"error": "Invalid round"}
    return {"message": "Task Received"}"""
    
@app.post("/handle_task")
async def handle_task(data: dict = Body(...), background_tasks: BackgroundTasks = None):
    if not validate_secret(data.get("secret", "")):
        return {"error": "Invalid secret"}

    # Run the round task in background
    background_tasks.add_task(run_task, data)

    # Immediately return 200 OK
    return {"message": "Task received and processing started."}
